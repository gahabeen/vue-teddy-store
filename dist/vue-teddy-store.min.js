/*!
  * vue-teddy-store v0.1.36
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
/*!
  * vue-teddy-store v0.1.36
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
var VueTeddyStore=function(e,t,s,r){"use strict";s=s&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s;var a="default"in r?r.default:r;function o(e){if(!t.isObject(e)||t.isObject(e)&&!("value"in e))return!1;return"function"==typeof Object.getOwnPropertyDescriptor(e,"value").get}function n(e,s,r){return t.isValidKey(s)&&(t.isObject(e)||Array.isArray(e))?o(e)&&"value"in e&&s in e.value?(e.value[s]=r,e.value[s]):(e[s]=r,e[s]):e&&null==s?(o(e)&&"value"in e?e.value=r:t.isObject(r)?Object.assign(e,r):e=r,e):void console.log("Couldn't not set "+s)}function c(e,s){return t.isValidKey(s)?o(e)?s in e.value?e.value[s]:e.value:t.isObject(e)||Array.isArray(e)?e[s]:void 0:e&&void 0===s?o(e)?e.value:e:void 0}function i(e,s){return!(!t.isObject(e)&&!Array.isArray(e))&&(!!t.isValidKey(s)&&(!!(o(e)&&e.value&&s in e.value)||(!(!e||!(s in e))||void 0)))}function u(e=[]){return["_state",...e]}const d=t.makeSet({setProp:n,getProp:c,hasProp:i,afterGetSteps:u}),p=t.makeHas({getProp:c,hasProp:i,afterGetSteps:u}),l=t.makeGet({getProp:c,hasProp:i,afterGetSteps:u}),y=t.makeSet({setProp:n,getProp:c,hasProp:i}),v=t.makeHas({getProp:c,hasProp:i}),f=t.makeGet({getProp:c,hasProp:i});var h=Object.freeze({__proto__:null,teddySet:d,teddyHas:p,teddyGet:l,set:y,has:v,get:f});s.use(a);const g=Symbol(),m=Symbol(),S=r.ref({__options:{devtools:!0},spaces:{}}),j=(e,t,s)=>{s=s||{};const r=R(e,t);return O(e,t,s.state),T(e,t,s.getters),_(e,t,s.actions),w(e,t,s.watchers),r},b=(e,t,s)=>r.isRef(s)?s:r.ref(s),k=(e,t,s,r={})=>(r._state=b(0,0,s),"state"in r||Object.defineProperty(r,"state",{get:()=>r._state.value,set:e=>{r._state.value=e},enumerable:!0}),r),O=(e,t,s)=>{const r=R(e,t);k(0,0,s,r)},P=(e,t,s)=>{const r=R(e,t);return s=s||{},Object.keys(s).reduce((e,t)=>(o(s[t])?e[t]=s[t]:"function"==typeof s[t]&&(e[t]=N(()=>s[t](r))),e),{})},T=(e,t,s)=>{const r=R(e,t);return r.getters={...r.getters||{},...P(e,t,s)},r},A=(e,t,s)=>{const r=R(e,t);return s=s||{},Object.keys(s).reduce((e,t)=>("function"==typeof s[t]&&(e[t]=(...e)=>s[t](r,...e)),e),{})},_=(e,t,s)=>{const r=R(e,t);return r.actions={...r.actions||{},...A(e,t,s)},r},G=(e,t,s)=>{const a=R(e,t),o=[];return Array.isArray(s)?o.push(...s):s&&o.push(s),0===o.length?[]:o.reduce((e,s)=>{const o=(t,s,a,o)=>{const n=r.watch(s,a,{deep:!0,...o});e.push({path:t,handler:a,options:o,unwatch:n})};if("function"==typeof s)o("state",()=>a.state,s,{deep:!0});else if(s&&"object"==typeof s&&"handler"in s){const{handler:e,path:r,paths:n=[],...c}=s;"string"==typeof r?o(r,()=>l(a,r),e,{deep:!0,...c}):n.length>0?o(n.map(e=>[t,e].filter(Boolean).filter(e=>e.length>0).join(".")),n.map(e=>()=>l(a,e)),e,{deep:!0,...c}):o("state",()=>a.state,e,{deep:!0,...c})}return e},[])},w=(e,t,s)=>{const r=R(e,t);return r.watchers=[...r.watchers||[],...G(e,t,s)],r},W=(e,t)=>void 0!==t?e in S.value.spaces&&"stores"in S.value.spaces[e]&&t in S.value.spaces[e].stores:e in S.value.spaces,V=(e,t)=>{const s=M(e);t in s.stores&&delete s.stores[t]},$=(e,t)=>{const s=M(e);for(const t in s.stores)V(e,t)},x=(e,t,s,r)=>{const a=R(e,t);return p(a,s,r)},H=(e,t,s,r)=>{const a=R(e,t);return l(a,s,r)},K=(e,t,s,r)=>function(){return H(e,t,s,r||this)},z=(e,t,s,r,a)=>{const o=R(e,t);d(o,s,r,a)},C=(e,t,s,r)=>function(a){z(e,t,s,a,r||this)},B=(e,s,r,a)=>{const o=(t,r)=>({get:K(e,s,t,r),set:C(e,s,t,r)});return Array.isArray(r)?r.reduce((e,t)=>(e[t]=o(t,a),e),{}):t.isObject(r)?Object.keys(r).reduce((e,t)=>(e[t]=o(r[t],a),e),{}):o(r,a)},D=(e=(e=>e))=>({setStore:e(j),makeState:e(b),setState:e(O),applyState:e(k),makeGetters:e(P),setGetters:e(T),makeActions:e(A),setActions:e(_),makeWatchers:e(G),setWatchers:e(w),exists:e(W),remove:e(V),reset:e($),has:e(x),get:e(H),getter:e(K),set:e(z),setter:e(C),sync:e(B)}),M=(e="$")=>(e in S.value.spaces||(S.value.spaces[e]={}),S.value.spaces[e]),R=(e="$",t="@")=>(M(e),"stores"in S.value.spaces[e]||(S.value.spaces[e].stores={}),t in S.value.spaces[e].stores||(S.value.spaces[e].stores[t]={getters:{},actions:{},watchers:[],options:{}},k(0,0,{},S.value.spaces[e].stores[t])),S.value.spaces[e].stores[t]),q=(e="$")=>{M(e);return D(t=>(...s)=>t(e,...s))},E=(...e)=>{let t=e[0]||"$",s=e[1]||"@";1===e.length&&(s=t,t=void 0);return D(e=>(...r)=>e(t,s,...r))},F=(e="$")=>{r.provide(g,q(e))},I=(...e)=>{r.provide(m,E(...e))},J=()=>{r.inject(g)},L=()=>{r.inject(m)},N=e=>{if(t.isObject(e)){const t="get"in e&&"function"==typeof e.get,s="set"in e&&"function"==typeof e.set;return t||s?r.computed(e):Object.keys(e).reduce((t,s)=>(t[s]=r.computed(e[s]),t),{})}return r.computed(e)};var Q=Object.freeze({__proto__:null,setStore:j,makeState:b,applyState:k,setState:O,makeGetters:P,setGetters:T,makeActions:A,setActions:_,makeWatchers:G,setWatchers:w,exists:W,remove:V,reset:$,has:x,get:H,getter:K,set:z,setter:C,sync:B,mapMethods:D,getTeddy:M,getTeddyStore:R,useTeddy:q,useTeddyStore:E,provideTeddy:F,provideTeddyStore:I,injectTeddy:J,injectTeddyStore:L,computed:N});return e.Teddies=S,e.accessors=h,e.computed=N,e.default=Q,e.exists=W,e.get=H,e.getTeddy=M,e.getTeddyStore=R,e.getter=K,e.has=x,e.injectTeddy=J,e.injectTeddyStore=L,e.makeActions=A,e.makeGetters=P,e.makeState=b,e.makeWatchers=G,e.provideTeddy=F,e.provideTeddyStore=I,e.remove=V,e.reset=$,e.set=z,e.setActions=_,e.setGetters=T,e.setState=O,e.setStore=j,e.setWatchers=w,e.setter=C,e.sync=B,e.useTeddy=q,e.useTeddyStore=E,e}({},objectStringPath,Vue,vueCompositionApi);
