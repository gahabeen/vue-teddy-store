/*!
  * vue-teddy-store v0.1.36
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
/*!
  * vue-teddy-store v0.1.36
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
var VueTeddyStore=function(e,t,s,r){"use strict";s=s&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s;var a="default"in r?r.default:r;function o(e){if(!t.isObject(e)||t.isObject(e)&&!("value"in e))return!1;return"function"==typeof Object.getOwnPropertyDescriptor(e,"value").get}function n(e,s,r){return t.isValidKey(s)&&(t.isObject(e)||Array.isArray(e))?o(e)&&"value"in e&&s in e.value?(e.value[s]=r,e.value[s]):(e[s]=r,e[s]):e&&null==s?(o(e)&&"value"in e?e.value=r:t.isObject(r)?Object.assign(e,r):e=r,e):void console.log("Couldn't not set "+s)}function c(e,s){return t.isValidKey(s)?o(e)?s in e.value?e.value[s]:e.value:t.isObject(e)||Array.isArray(e)?e[s]:void 0:e&&void 0===s?o(e)?e.value:e:void 0}function i(e,s){return!(!t.isObject(e)&&!Array.isArray(e))&&(!!t.isValidKey(s)&&(!!(o(e)&&e.value&&s in e.value)||(!(!e||!(s in e))||void 0)))}function u(e=[]){return["_state",...e]}const d=t.makeSet({setProp:n,getProp:c,hasProp:i,afterGetSteps:u}),p=t.makeHas({getProp:c,hasProp:i,afterGetSteps:u}),l=t.makeGet({getProp:c,hasProp:i,afterGetSteps:u}),y=t.makeSet({setProp:n,getProp:c,hasProp:i}),v=t.makeHas({getProp:c,hasProp:i}),f=t.makeGet({getProp:c,hasProp:i});var m=Object.freeze({__proto__:null,teddySet:d,teddyHas:p,teddyGet:l,set:y,has:v,get:f});s.use(a);const h=Symbol(),g=Symbol(),S=r.ref({__options:{devtools:!0},spaces:{}}),j=(e="$",s="@")=>{let r=e,a=s;return t.isObject(e)&&(r=e.space||r,a=e.name||a),{space:r,name:a}},b=(e,t)=>{t=t||{};const s=I(e);return O(e,t.state),A(e,t.getters),G(e,t.actions),$(e,t.watchers),s},T=(e,t)=>r.isRef(t)?t:r.ref(t),k=(e,t,s={})=>(s._state=T(0,t),"state"in s||Object.defineProperty(s,"state",{get:()=>s._state.value,set:e=>{s._state.value=e},enumerable:!0}),s),O=(e,t)=>{const s=I(e);k(0,t,s)},P=(e,t)=>{const s=I(e);return t=t||{},Object.keys(t).reduce((e,r)=>(o(t[r])?e[r]=t[r]:"function"==typeof t[r]&&(e[r]=X(()=>t[r](s))),e),{})},A=(e,t)=>{const s=I(e);return s.getters={...s.getters||{},...P(e,t)},s},_=(e,t)=>{const s=I(e);return t=t||{},Object.keys(t).reduce((e,r)=>("function"==typeof t[r]&&(e[r]=(...e)=>t[r](s,...e)),e),{})},G=(e,t)=>{const s=I(e);return s.actions={...s.actions||{},..._(e,t)},s},w=(e,t)=>{const{name:s}=j(e),a=I(e),o=[];return Array.isArray(t)?o.push(...t):t&&o.push(t),0===o.length?[]:o.reduce((e,t)=>{const o=(t,s,a,o)=>{const n=r.watch(s,a,{deep:!0,...o});e.push({path:t,handler:a,options:o,unwatch:n})};if("function"==typeof t)o("state",()=>a.state,t,{deep:!0});else if(t&&"object"==typeof t&&"handler"in t){const{handler:e,path:r,paths:n=[],...c}=t;"string"==typeof r?o(r,()=>l(a,r),e,{deep:!0,...c}):n.length>0?o(n.map(e=>[s,e].filter(Boolean).filter(e=>e.length>0).join(".")),n.map(e=>()=>l(a,e)),e,{deep:!0,...c}):o("state",()=>a.state,e,{deep:!0,...c})}return e},[])},$=(e,t)=>{const s=I(e);return s.watchers=[...s.watchers||[],...w(e,t)],s},W=e=>{const{space:t,name:s}=j(e);return void 0!==s?t in S.value.spaces&&"stores"in S.value.spaces[t]&&s in S.value.spaces[t].stores:t in S.value.spaces},V=e=>{const{space:t,name:s}=j(e),r=R(t);s in r.stores&&delete r.stores[s]},x=e=>{},D=(e,t,s)=>{const r=I(e);return p(r,t,s)},H=(e,t,s)=>{const r=I(e);return l(r,t,s)},K=(e,t,s)=>function(){return H(e,t,s||this)},z=(e,t,s,r)=>{const a=I(e);d(a,t,s,r)},C=(e,t,s)=>function(r){z(e,t,r,s||this)},M=(e,s,r)=>{const a=(t,s)=>({get:K(e,t,s),set:C(e,t,s)});return Array.isArray(s)?s.reduce((e,t)=>(e[t]=a(t,r),e),{}):t.isObject(s)?Object.keys(s).reduce((e,t)=>(e[t]=a(s[t],r),e),{}):a(s,r)},B=(e=(e=>e))=>({setStore:e(b),makeState:e(T),setState:e(O),applyState:e(k),makeGetters:e(P),setGetters:e(A),makeActions:e(_),setActions:e(G),makeWatchers:e(w),setWatchers:e($),exists:e(W),remove:e(V),reset:e(x),has:e(D),get:e(H),getter:e(K),set:e(z),setter:e(C),sync:e(M)}),R=(e="$")=>(e in S.value.spaces||(S.value.spaces[e]={}),S.value.spaces[e]),q=(e="$")=>({store:R(e),...B(t=>(...s)=>t({space:e,name:"@"},...s))}),E=(e="@")=>I("$",e),F=(e="@")=>({store:E(e),...B(t=>(...s)=>t({name:e,space:"$"},...s))}),I=(e,t)=>{const{space:s,name:r}=j(e,t);return R(s),"stores"in S.value.spaces[s]||(S.value.spaces[s].stores={}),r in S.value.spaces[s].stores||(S.value.spaces[s].stores[r]={getters:{},actions:{},watchers:[],options:{}},k(0,{},S.value.spaces[s].stores[r])),S.value.spaces[s].stores[r]},J=(e="$",t="@")=>({store:I(e,t),...B(s=>(...r)=>s({space:e,name:t},...r))}),L=(e="$")=>{r.provide(h,q(e))},N=(...e)=>{r.provide(g,J(...e))},Q=()=>{r.inject(h)},U=()=>{r.inject(g)},X=e=>{if(t.isObject(e)){const t="get"in e&&"function"==typeof e.get,s="set"in e&&"function"==typeof e.set;return t||s?r.computed(e):Object.keys(e).reduce((t,s)=>(t[s]=r.computed(e[s]),t),{})}return r.computed(e)};var Y=Object.freeze({__proto__:null,accessors:m,Teddy:h,TeddyStore:g,Teddies:S,parseDefinition:j,setStore:b,makeState:T,applyState:k,setState:O,makeGetters:P,setGetters:A,makeActions:_,setActions:G,makeWatchers:w,setWatchers:$,exists:W,remove:V,reset:x,has:D,get:H,getter:K,set:z,setter:C,sync:M,mapMethods:B,getTeddy:R,useTeddy:q,getStore:E,useStore:F,getTeddyStore:I,useTeddyStore:J,provideTeddy:L,provideTeddyStore:N,injectTeddy:Q,injectTeddyStore:U,computed:X});return e.Teddies=S,e.Teddy=h,e.TeddyStore=g,e.accessors=m,e.applyState=k,e.computed=X,e.exists=W,e.get=H,e.getStore=E,e.getTeddy=R,e.getTeddyStore=I,e.getter=K,e.has=D,e.injectTeddy=Q,e.injectTeddyStore=U,e.install=e=>{e.prototype.$teddy=Y},e.makeActions=_,e.makeGetters=P,e.makeState=T,e.makeWatchers=w,e.mapMethods=B,e.parseDefinition=j,e.provideTeddy=L,e.provideTeddyStore=N,e.remove=V,e.reset=x,e.set=z,e.setActions=G,e.setGetters=A,e.setState=O,e.setStore=b,e.setWatchers=$,e.setter=C,e.sync=M,e.useStore=F,e.useTeddy=q,e.useTeddyStore=J,e}({},objectStringPath,Vue,vueCompositionApi);
