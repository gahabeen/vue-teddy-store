/*!
  * vue-teddy-store v0.1.25
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
/*!
  * vue-teddy-store v0.1.25
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
var VueTeddyStore=function(t,e){"use strict";const s=t=>"teddy:store:"+t;var r={handle({name:e,store:r}){const i=window.localStorage||global.localStorage||{};if(i){const n=i.getItem(s(e));n&&(r.state={...r.state,...JSON.parse(n)}),t.watch(r.state,(t,r)=>{t!==r&&i.setItem(s(e),JSON.stringify(t))},{immediate:!0,deep:!0})}}},i={handle({store:e}){e._history=t.reactive([]),t.watch(e.state,t=>{e._history.push(t)},{immediate:!0,deep:!0})}},n={handle({name:e,store:r}){window&&window.addEventListener("storage",i=>{i.key===s(e)&&(r.state=t.reactive({...r.state,...JSON.parse(i.newValue)}))})}},a=Object.freeze({__proto__:null,cache:r,history:i,sync:n});function o(t){if(!e.isObject(t)||e.isObject(t)&&!("value"in t))return!1;return"function"==typeof Object.getOwnPropertyDescriptor(t,"value").get}function c(t,s){return e.isValidKey(s)?o(t)?s in t.value?t.value[s]:t.value:e.isObject(t)||Array.isArray(t)?t[s]:void 0:t&&void 0===s?o(t)?t.value:t:void 0}function h(t,s){return!(!e.isObject(t)&&!Array.isArray(t))&&(!!e.isValidKey(s)&&(!(!o(t)||!(s in t.value))||(s in t||void 0)))}const u=e.makeSet({setProp:function(t,s,r){return e.isValidKey(s)&&(e.isObject(t)||Array.isArray(t))?o(t)&&s in t.value?(t.value[s]=r,t.value[s]):(t[s]=r,t[s]):t&&null==s?(o(t)?t.value=r:e.isObject(r)?Object.assign(t,r):t=r,t):void console.log("Couldn't not set "+s)},getProp:c,hasProp:h}),l=e.makeHas({getProp:c,hasProp:h}),d=e.makeGet({getProp:c,hasProp:h});function p(t){const s=t.filter(t=>t&&e.isObject(t)&&t instanceof g),r=t.filter(t=>t&&e.isObject(t)&&"$teddy"in t&&t.$teddy instanceof g),i=t.filter(t=>!s.includes(t)&&!r.includes(t));return{instances:s,hosted:r,others:i}}function f(...t){const{instances:e,hosted:s}=p(t),r=[...e,...s.map(t=>t.$teddy)];if(0===!e.length)throw new Error("Couldn't find any proper instance!");return r[0]}function y(...t){const{hosted:e,others:s}=p(t),r=[...e,...s];if(0===!r.length)throw new Error("Couldn't find any proper context!");return r[0]}class g{constructor(){this._stores={},this._plugins=a}add(e,s){const r=function(t,e=[]){return Object.keys(t).reduce((s,r)=>(r.includes(e)||(s[r]=t[r]),s),{})}(s,["state","methods","watchers"]);this._stores[e]={...g.createState(s.state),...s.methods||{},...r},this[e]=this._stores[e];const i=[];Array.isArray(s.watchers)?i.push(...s.watchers):s.watcher&&i.push(s.watcher);for(let s of i)if("function"==typeof s)t.watch(()=>this._stores[e].state.value,s,{deep:!0});else if(s&&"object"==typeof s&&"handler"in s){const{handler:r,path:i,paths:n=[],...a}=s;i?t.watch(()=>d(this._stores[e].state.value,i),r,{deep:!0,...a}):n.length>0?t.watch(n.map(t=>()=>d(this._stores[e].state.value,t)),r,{deep:!0,...a}):t.watch(()=>this._stores[e].state.value,r,{deep:!0,...a})}return this}remove(t){t in this&&delete this[t],t in this._stores&&delete this._stores[t]}use(t={}){return"function"==typeof t.install&&t.install(this),"function"==typeof t.handle&&Object.keys(this._stores).map(e=>t.handle.call(this,{name:e,store:this._stores[e]})),this}activate(t=[]){Array.isArray(t)||(t=[t]);for(let e of t)e in this._plugins&&this.use(this._plugins[e]);return this}install(t){t.prototype.$teddy=this}get stores(){return this._stores}static createState(e){return t.isRef(e)?e:t.ref(e)}has(t,e){return g.has(t,e,this)}static has(t,e,s){const r=f(this,s),i=y(this,s);return l(r,`_stores.${t}.state.${e}`,i)}get(t,e){return g.get(t,e,this)}static get(t,e,s){const r=f(this,s),i=y(this,s);return d(r,`_stores.${t}.state.${e}`,i)}getter(t,e){return g.getter(t,e,this)}static getter(t,e,s){return s=s||this,function(){return g.get.call(this,t,e,s)}}set(t,e,s){return g.set(t,e,s,this)}static set(t,e,s,r){const i=f(this,r),n=y(this,r);u(i,`_stores.${t}.state.${e}`,s,n)}setter(t,e){return g.setter(t,e,this)}static setter(t,e,s){return s=s||this,function(r){g.set.call(this,t,e,r,s)}}compute(t,e){return g.compute(t,e,this)}static _compute(t,e,s){s=s||this;return{get:g.getter(t,e,s),set:g.setter(t,e,s)}}static compute(t,s,r){return r=r||this,e.isObject(s)?Object.keys(s).reduce((e,i)=>(e[i]=g._compute(t,s[i],r),e),{}):g._compute(t,s,r)}}return g}(vueCompositionApi,objectStringPath);
