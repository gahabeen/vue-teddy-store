/*!
  * vue-teddy-store v0.1.34
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
/*!
  * vue-teddy-store v0.1.34
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
import{isObject as t,makeGet as e,isValidKey as s,makeSet as r,makeHas as o}from"object-string-path";import{watch as n,reactive as i,isRef as a,ref as c,computed as h}from"@vue/composition-api";import u from"vue";function d(e){if(!t(e)||t(e)&&!("value"in e))return!1;return"function"==typeof Object.getOwnPropertyDescriptor(e,"value").get}function l(t){return t.filter(Boolean).filter(t=>t.length>0).join(".")}function p(e,r,o){return s(r)&&(t(e)||Array.isArray(e))?d(e)&&"value"in e&&r in e.value?(e.value[r]=o,e.value[r]):(e[r]=o,e[r]):e&&null==r?(d(e)&&"value"in e?e.value=o:t(o)?Object.assign(e,o):e=o,e):void console.log("Couldn't not set "+r)}function f(e,r){return s(r)?d(e)?r in e.value?e.value[r]:e.value:t(e)||Array.isArray(e)?e[r]:void 0:e&&void 0===r?d(e)?e.value:e:void 0}function g(e,r){return!(!t(e)&&!Array.isArray(e))&&(!!s(r)&&(!!(d(e)&&e.value&&r in e.value)||(!(!e||!(r in e))||void 0)))}function y(t){return e=>{const[s,...r]=e||[];return s?(t(s),["_stores",s,"state",...r]):[]}}const _=(t=(t=>t))=>r({setProp:p,getProp:f,hasProp:g,afterGetSteps:y(t)}),v=(t=(t=>t))=>o({getProp:f,hasProp:g,afterGetSteps:y(t)}),m=(t=(t=>t))=>e({getProp:f,hasProp:g,afterGetSteps:y(t)}),P=r({setProp:p,getProp:f,hasProp:g}),w=o({getProp:f,hasProp:g}),b=e({getProp:f,hasProp:g});var S=Object.freeze({__proto__:null,makeTeddySet:_,makeTeddyHas:v,makeTeddyGet:m,set:P,has:w,get:b});const O=t=>"teddy:store:"+t;var j={handle({name:t,store:e}){const s=window.localStorage||global.localStorage||{};if(s){const r=s.getItem(O(t));r&&(e.state={...e.state,...JSON.parse(r)}),n(()=>e.state,(e,r)=>{e!==r&&s.setItem(O(t),JSON.stringify(e))},{immediate:!0,deep:!0})}}},A={handle({store:t}){t._history=i([]),n(t.state,e=>{t._history.push(e)},{immediate:!0,deep:!0})}},x={handle({name:t,store:e}){window&&window.addEventListener("storage",s=>{s.key===O(t)&&(e.state={...e.state,...JSON.parse(s.newValue)})})}},$=Object.freeze({__proto__:null,cache:j,history:A,sync:x});let k;class G extends Error{constructor(t){super(t),this.name="MissingStoreError"}}class E{constructor(t){this._options={devtools:u.config.devtools,...t||{}},this._vueInstance=null,this._stores={},this._features=$}add(t,e){return e=e||{},this._stores[t]={},this[t]=this._stores[t],this.addState(t,e.state),this.addGetters(t,e.getters),this.addActions(t,e.actions),this.addStoreProperties(t,function(t,e=[]){return Object.keys(t).reduce((s,r)=>(e.includes(r)||(s[r]=t[r]),s),{})}(e,["state","getters","actions","watcher","watchers","devtools"])),this.registerWatchers(t,e.watcher),this.registerWatchers(t,e.watchers),this}addStoreProperties(t,e,s){const{allowOverriding:r=!1,alsoAtPath:o=null}=s||{};this._stores[t]||(this._stores[t]={});for(const s of Object.keys(e||{}))!(s in this._stores[t])||r?(this._stores[t][s]=e[s],"string"==typeof o&&(this._stores[t][o]||(this._stores[t][o]={}),this._stores[t][o][s]=this._stores[t][s])):console.warn(`addStoreProperties('${t}',...) - Couldn't override property ${s} on store '${t}'`);return this}addState(t,e){this._stores[t]||(this._stores[t]={});const s=I(e);return this._stores[t]._state=s,Object.defineProperty(this._stores[t],"state",{get:()=>s.value,set:t=>{s.value=t},enumerable:!0}),this}addGetters(t,e){return this.addStoreProperties(t,T(this._stores[t],e),{alsoAtPath:"_getters"}),this}addActions(t,e){return this.addStoreProperties(t,W(this._stores[t],e),{alsoAtPath:"_actions"}),this}registerWatchers(t,e){const s=[];if(Array.isArray(e)?s.push(...e):e&&s.push(e),this.exists(t)&&0!==s.length){for(let e of s)if("function"==typeof e)n(()=>this._stores[t].state,e,{deep:!0});else if(e&&"object"==typeof e&&"handler"in e){const{handler:s,path:r,paths:o=[],...i}=e;"string"==typeof r?(console.log(">> register watcher",r,m()(this,l([t,r]))),n(()=>m()(this,l([t,r])),s,{deep:!0,...i})):o.length>0?n(o.map(e=>()=>m()(this,l([t,e]))),s,{deep:!0,...i}):n(()=>this._stores[t].state,s,{deep:!0,...i})}return this}}exists(t){return t in this._stores}remove(t){t in this&&delete this[t],t in this._stores&&delete this._stores[t]}reset(){for(let t in this._stores)this.remove(t)}use(t={}){return"function"==typeof t.install&&t.install(this),"function"==typeof t.handle&&Object.keys(this._stores).map(e=>t.handle.call(this,{name:e,store:this._stores[e]})),this}activate(t=[]){Array.isArray(t)||(t=[t]);for(let e of t)e in this._features&&this.use(this._features[e]);return this}attachTo(t){return this._vueInstance=t,this}install(...t){const e=this,[s]=t;if(s.version.startsWith("2")){if(k&&s===k)return;k=s,Object.defineProperty(s.prototype,"$teddy",{get(){return e.attachTo(this)},enumerable:!0,configurable:!0})}else if(s.version.startsWith("3")){const[s]=t;s.provide("$teddy"),Object.defineProperty(s.config.globalProperties,"$teddy",{get(){return e.attachTo(this)},configurable:!0})}}get stores(){return this._stores}has(t,e){return M(t,e)}get(t,e){return z(t,e)}getter(t,e){return J(t,e)}set(t,e,s){return C(t,e,s)}setter(t,e){return N(t,e)}sync(t,e){return Y(t,e)}computed(t){return B(t)}}const I=(t={})=>a(t)?t:c(t),T=(t,e)=>(e=e||{},Object.keys(e).reduce((s,r)=>{if(d(e[r]))s[r]=e[r];else if("function"==typeof e[r]){const o={state:t.state,getters:t.getters};s[r]=B(()=>e[r](o))}return s},{})),W=(t,e)=>(e=e||{},Object.keys(e).reduce((s,r)=>{if("function"==typeof e[r]){const o={state:t.state,getters:t.getters};s[r]=(...t)=>e[r](o,...t)}return s},{})),M=(t,e)=>{const s=k.prototype.$teddy;return v(e=>{if(!s.exists(e))throw new G(`You're trying to use the method .has('${t}', context?) on a store which doesn't exists: '${e}'`)})(s,t,D(e,s))},z=(t,e)=>{const s=k.prototype.$teddy;return m(e=>{if(!s.exists(e))throw new G(`You're trying to use the method .get('${t}', context?) on a store which doesn't exists: '${e}'`)})(s,t,D(e,s))},C=(t,e,s)=>{const r=k.prototype.$teddy;_(e=>{if(!r.exists(e))throw new G(`You're trying to use the method .set('${t}', value, context?) on a store which doesn't exists: '${e}'`)})(r,t,e,D(s,r))},J=(t,e)=>function(){return z(t,e)},N=(t,e)=>function(s){C(t,s,e)},Y=(e,s)=>{const r=(t,e)=>({get:J(t,e),set:N(t,e)});return Array.isArray(e)?e.reduce((t,e)=>(t[e]=r(e,s),t),{}):t(e)?Object.keys(e).reduce((t,o)=>(t[o]=r(e[o],s),t),{}):r(e,s)},B=e=>{if(t(e)){const t="get"in e&&"function"==typeof e.get,s="set"in e&&"function"==typeof e.set;return t||s?h(e):Object.keys(e).reduce((t,s)=>(t[s]=h(e[s]),t),{})}return h(e)};function D(...e){return e.filter(Boolean).reduce((e,s)=>s instanceof E&&s._vueInstance?s._vueInstance:t(s)?s:e,{})}var H=Object.freeze({__proto__:null,MissingStoreError:G,default:E,createState:I,createGetters:T,createActions:W,has:M,get:z,set:C,getter:J,setter:N,sync:Y,computed:B,resolveContext:D});const{has:L,get:V,set:q,sync:F,computed:K,setter:Q,getter:R,createGetters:U,createState:X,MissingStoreError:Z}=H;export default E;export{Z as MissingStoreError,S as accessors,K as computed,U as createGetters,X as createState,V as get,R as getter,L as has,q as set,Q as setter,F as sync};
