/*!
  * vue-teddy-store v0.1.36
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
/*!
  * vue-teddy-store v0.1.36
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
import{isObject as e,makeSet as t,makeHas as s,makeGet as r,isValidKey as o}from"object-string-path";import a from"vue";import n,{ref as c,isRef as u,provide as i,inject as p,computed as l,watch as d}from"@vue/composition-api";function v(t){if(!e(t)||e(t)&&!("value"in t))return!1;return"function"==typeof Object.getOwnPropertyDescriptor(t,"value").get}function y(t,s,r){return o(s)&&(e(t)||Array.isArray(t))?v(t)&&"value"in t&&s in t.value?(t.value[s]=r,t.value[s]):(t[s]=r,t[s]):t&&null==s?(v(t)&&"value"in t?t.value=r:e(r)?Object.assign(t,r):t=r,t):void console.log("Couldn't not set "+s)}function f(t,s){return o(s)?v(t)?s in t.value?t.value[s]:t.value:e(t)||Array.isArray(t)?t[s]:void 0:t&&void 0===s?v(t)?t.value:t:void 0}function h(t,s){return!(!e(t)&&!Array.isArray(t))&&(!!o(s)&&(!!(v(t)&&t.value&&s in t.value)||(!(!t||!(s in t))||void 0)))}function g(e=[]){return["_state",...e]}const m=t({setProp:y,getProp:f,hasProp:h,afterGetSteps:g}),S=s({getProp:f,hasProp:h,afterGetSteps:g}),P=r({getProp:f,hasProp:h,afterGetSteps:g}),b=t({setProp:y,getProp:f,hasProp:h}),j=s({getProp:f,hasProp:h}),A=r({getProp:f,hasProp:h});var _=Object.freeze({__proto__:null,teddySet:m,teddyHas:S,teddyGet:P,set:b,has:j,get:A});a.use(n);const k=Symbol(),O=Symbol(),G=c({__options:{devtools:!0},spaces:{}}),T=(e,t,s)=>{s=s||{};const r=U(e,t);return x(e,t,s.state),z(e,t,s.getters),C(e,t,s.actions),H(e,t,s.watchers),r},w=(e,t,s)=>u(s)?s:c(s),$=(e,t,s,r={})=>(r._state=w(0,0,s),"state"in r||Object.defineProperty(r,"state",{get:()=>r._state.value,set:e=>{r._state.value=e},enumerable:!0}),r),x=(e,t,s)=>{const r=U(e,t);$(0,0,s,r)},W=(e,t,s)=>{const r=U(e,t);return s=s||{},Object.keys(s).reduce((e,t)=>(v(s[t])?e[t]=s[t]:"function"==typeof s[t]&&(e[t]=se(()=>s[t](r))),e),{})},z=(e,t,s)=>{const r=U(e,t);return r.getters={...r.getters||{},...W(e,t,s)},r},B=(e,t,s)=>{const r=U(e,t);return s=s||{},Object.keys(s).reduce((e,t)=>("function"==typeof s[t]&&(e[t]=(...e)=>s[t](r,...e)),e),{})},C=(e,t,s)=>{const r=U(e,t);return r.actions={...r.actions||{},...B(e,t,s)},r},D=(e,t,s)=>{const r=U(e,t),o=[];return Array.isArray(s)?o.push(...s):s&&o.push(s),0===o.length?[]:o.reduce((e,s)=>{const o=(t,s,r,o)=>{const a=d(s,r,{deep:!0,...o});e.push({path:t,handler:r,options:o,unwatch:a})};if("function"==typeof s)o("state",()=>r.state,s,{deep:!0});else if(s&&"object"==typeof s&&"handler"in s){const{handler:e,path:a,paths:n=[],...c}=s;"string"==typeof a?o(a,()=>P(r,a),e,{deep:!0,...c}):n.length>0?o(n.map(e=>[t,e].filter(Boolean).filter(e=>e.length>0).join(".")),n.map(e=>()=>P(r,e)),e,{deep:!0,...c}):o("state",()=>r.state,e,{deep:!0,...c})}return e},[])},H=(e,t,s)=>{const r=U(e,t);return r.watchers=[...r.watchers||[],...D(e,t,s)],r},M=(e,t)=>void 0!==t?e in G.value.spaces&&"stores"in G.value.spaces[e]&&t in G.value.spaces[e].stores:e in G.value.spaces,q=(e,t)=>{const s=R(e);t in s.stores&&delete s.stores[t]},E=(e,t)=>{const s=R(e);for(const t in s.stores)q(e,t)},F=(e,t,s,r)=>{const o=U(e,t);return S(o,s,r)},I=(e,t,s,r)=>{const o=U(e,t);return P(o,s,r)},J=(e,t,s,r)=>function(){return I(e,t,s,r||this)},K=(e,t,s,r,o)=>{const a=U(e,t);m(a,s,r,o)},L=(e,t,s,r)=>function(o){K(e,t,s,o,r||this)},N=(t,s,r,o)=>{const a=(e,r)=>({get:J(t,s,e,r),set:L(t,s,e,r)});return Array.isArray(r)?r.reduce((e,t)=>(e[t]=a(t,o),e),{}):e(r)?Object.keys(r).reduce((e,t)=>(e[t]=a(r[t],o),e),{}):a(r,o)},Q=(e=(e=>e))=>({setStore:e(T),makeState:e(w),setState:e(x),applyState:e($),makeGetters:e(W),setGetters:e(z),makeActions:e(B),setActions:e(C),makeWatchers:e(D),setWatchers:e(H),exists:e(M),remove:e(q),reset:e(E),has:e(F),get:e(I),getter:e(J),set:e(K),setter:e(L),sync:e(N)}),R=(e="$")=>(e in G.value.spaces||(G.value.spaces[e]={}),G.value.spaces[e]),U=(e="$",t="@")=>(R(e),"stores"in G.value.spaces[e]||(G.value.spaces[e].stores={}),t in G.value.spaces[e].stores||(G.value.spaces[e].stores[t]={getters:{},actions:{},watchers:[],options:{}},$(0,0,{},G.value.spaces[e].stores[t])),G.value.spaces[e].stores[t]),V=(e="$")=>{R(e);return Q(t=>(...s)=>t(e,...s))},X=(...e)=>{let t=e[0]||"$",s=e[1]||"@";1===e.length&&(s=t,t=void 0);return Q(e=>(...r)=>e(t,s,...r))},Y=(e="$")=>{i(k,V(e))},Z=(...e)=>{i(O,X(...e))},ee=()=>{p(k)},te=()=>{p(O)},se=t=>{if(e(t)){const e="get"in t&&"function"==typeof t.get,s="set"in t&&"function"==typeof t.set;return e||s?l(t):Object.keys(t).reduce((e,s)=>(e[s]=l(t[s]),e),{})}return l(t)};var re=Object.freeze({__proto__:null,setStore:T,makeState:w,applyState:$,setState:x,makeGetters:W,setGetters:z,makeActions:B,setActions:C,makeWatchers:D,setWatchers:H,exists:M,remove:q,reset:E,has:F,get:I,getter:J,set:K,setter:L,sync:N,mapMethods:Q,getTeddy:R,getTeddyStore:U,useTeddy:V,useTeddyStore:X,provideTeddy:Y,provideTeddyStore:Z,injectTeddy:ee,injectTeddyStore:te,computed:se});export default re;export{G as Teddies,_ as accessors,se as computed,M as exists,I as get,R as getTeddy,U as getTeddyStore,J as getter,F as has,ee as injectTeddy,te as injectTeddyStore,B as makeActions,W as makeGetters,w as makeState,D as makeWatchers,Y as provideTeddy,Z as provideTeddyStore,q as remove,E as reset,K as set,C as setActions,z as setGetters,x as setState,T as setStore,H as setWatchers,L as setter,N as sync,V as useTeddy,X as useTeddyStore};
