/*!
  * vue-teddy-store v0.1.36
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
/*!
  * vue-teddy-store v0.1.36
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
import{isObject as t,makeGet as e,isValidKey as s,makeSet as r,makeHas as o}from"object-string-path";import{watch as i,reactive as n,isRef as a,ref as h,computed as c}from"@vue/composition-api";import u from"vue";function d(e){if(!t(e)||t(e)&&!("value"in e))return!1;return"function"==typeof Object.getOwnPropertyDescriptor(e,"value").get}function l(t){return t.filter(Boolean).filter(t=>t.length>0).join(".")}function p(e,r,o){return s(r)&&(t(e)||Array.isArray(e))?d(e)&&"value"in e&&r in e.value?(e.value[r]=o,e.value[r]):(e[r]=o,e[r]):e&&null==r?(d(e)&&"value"in e?e.value=o:t(o)?Object.assign(e,o):e=o,e):void console.log("Couldn't not set "+r)}function f(e,r){return s(r)?d(e)?r in e.value?e.value[r]:e.value:t(e)||Array.isArray(e)?e[r]:void 0:e&&void 0===r?d(e)?e.value:e:void 0}function y(e,r){return!(!t(e)&&!Array.isArray(e))&&(!!s(r)&&(!!(d(e)&&e.value&&r in e.value)||(!(!e||!(r in e))||void 0)))}function g(t){return e=>{const[s,...r]=e||[];return s?(t(s),["_stores",s,"state",...r]):[]}}const _=(t=(t=>t))=>r({setProp:p,getProp:f,hasProp:y,afterGetSteps:g(t)}),v=(t=(t=>t))=>o({getProp:f,hasProp:y,afterGetSteps:g(t)}),m=(t=(t=>t))=>e({getProp:f,hasProp:y,afterGetSteps:g(t)}),P=r({setProp:p,getProp:f,hasProp:y}),w=o({getProp:f,hasProp:y}),S=e({getProp:f,hasProp:y});var b=Object.freeze({__proto__:null,makeTeddySet:_,makeTeddyHas:v,makeTeddyGet:m,set:P,has:w,get:S});const O=t=>"teddy:store:"+t;var A={handle({name:t,store:e}){const s=window.localStorage||global.localStorage||{};if(s){const r=s.getItem(O(t));r&&(e.state={...e.state,...JSON.parse(r)}),i(()=>e.state,(e,r)=>{e!==r&&s.setItem(O(t),JSON.stringify(e))},{immediate:!0,deep:!0})}}},j={handle({store:t}){t._history=n([]),i(t.state,e=>{t._history.push(e)},{immediate:!0,deep:!0})}},$={handle({name:t,store:e}){window&&window.addEventListener("storage",s=>{s.key===O(t)&&(e.state={...e.state,...JSON.parse(s.newValue)})})}},x=Object.freeze({__proto__:null,cache:A,history:j,sync:$});let k;class G extends Error{constructor(t){super(t),this.name="MissingStoreError"}}class E{constructor(t){this._options={devtools:u.config.devtools,...t||{}},this._vueInstance=null,this._stores={},this._features=x}add(t,e){return e=e||{},this._stores[t]={},this[t]=this._stores[t],this.addState(t,e.state),this.addGetters(t,e.getters),this.addActions(t,e.actions),this.addStoreProperties(t,function(t,e=[]){return Object.keys(t).reduce((s,r)=>(e.includes(r)||(s[r]=t[r]),s),{})}(e,["state","getters","actions","watcher","watchers","devtools"])),this.registerWatchers(t,e.watcher),this.registerWatchers(t,e.watchers),this}addStoreProperties(t,e,s){const{allowOverriding:r=!1,alsoAtPath:o=null}=s||{};this._stores[t]||(this._stores[t]={});for(const s of Object.keys(e||{}))!(s in this._stores[t])||r?(this._stores[t][s]=e[s],"string"==typeof o&&(this._stores[t][o]||(this._stores[t][o]={}),this._stores[t][o][s]=this._stores[t][s])):console.warn(`addStoreProperties('${t}',...) - Couldn't override property ${s} on store '${t}'`);return this}addState(t,e){this._stores[t]||(this._stores[t]={});const s=T(e);return this._stores[t]._state=s,Object.defineProperty(this._stores[t],"state",{get:()=>s.value,set:t=>{s.value=t},enumerable:!0}),this}addGetters(t,e){return this.addStoreProperties(t,W(this._stores[t],e),{alsoAtPath:"_getters"}),this}addActions(t,e){return this.addStoreProperties(t,I(this._stores[t],e),{alsoAtPath:"_actions"}),this}registerWatchers(t,e){const s=[];if(Array.isArray(e)?s.push(...e):e&&s.push(e),this.exists(t)&&0!==s.length){for(let e of s)if("function"==typeof e)i(()=>this._stores[t].state,e,{deep:!0});else if(e&&"object"==typeof e&&"handler"in e){const{handler:s,path:r,paths:o=[],...n}=e;"string"==typeof r?i(()=>m()(this,l([t,r])),s,{deep:!0,...n}):o.length>0?i(o.map(e=>()=>m()(this,l([t,e]))),s,{deep:!0,...n}):i(()=>this._stores[t].state,s,{deep:!0,...n})}return this}}exists(t){return t in this._stores}remove(t){t in this&&delete this[t],t in this._stores&&delete this._stores[t]}reset(){for(let t in this._stores)this.remove(t)}use(t={}){return"function"==typeof t.install&&t.install(this),"function"==typeof t.handle&&Object.keys(this._stores).map(e=>t.handle.call(this,{name:e,store:this._stores[e]})),this}activate(t=[]){Array.isArray(t)||(t=[t]);for(let e of t)e in this._features&&this.use(this._features[e]);return this}attachTo(t){return this._vueInstance=t,this}install(...t){const e=this,[s]=t;if(s.version.startsWith("2")){if(k&&s===k)return;k=s,s.prototype.$teddy=e}else if(s.version.startsWith("3")){const[s]=t;s.provide("$teddy"),Object.defineProperty(s.config.globalProperties,"$teddy",{get(){return e.attachTo(this)},configurable:!0})}}get stores(){return this._stores}has(t,e){return M(t,e)}get(t,e){return z(t,e)}getter(t,e){return N(t,e)}set(t,e,s){return J(t,e,s)}setter(t,e){return Y(t,e)}sync(t,e){return C(t,e)}computed(t){return B(t)}}const T=(t={})=>a(t)?t:h(t),W=(t,e)=>(e=e||{},Object.keys(e).reduce((s,r)=>{if(d(e[r]))s[r]=e[r];else if("function"==typeof e[r]){const o={state:t.state,getters:t.getters};s[r]=B(()=>e[r](o))}return s},{})),I=(t,e)=>(e=e||{},Object.keys(e).reduce((s,r)=>{if("function"==typeof e[r]){const o={state:t.state,getters:t.getters};s[r]=(...t)=>e[r](o,...t)}return s},{})),M=(t,e)=>{const s=k.prototype.$teddy;return v(e=>{if(!s.exists(e))throw new G(`You're trying to use the method .has('${t}', context?) on a store which doesn't exists: '${e}'`)})(s,t,e)},z=(t,e)=>{const s=k.prototype.$teddy;return m(e=>{if(!s.exists(e))throw new G(`You're trying to use the method .get('${t}', context?) on a store which doesn't exists: '${e}'`)})(s,t,e)},J=(t,e,s)=>{const r=k.prototype.$teddy;_(e=>{if(!r.exists(e))throw new G(`You're trying to use the method .set('${t}', value, context?) on a store which doesn't exists: '${e}'`)})(r,t,e,s)},N=(t,e)=>function(){return z(t,e||this)},Y=(t,e)=>function(s){J(t,s,e||this)},C=(e,s)=>{const r=(t,e)=>({get:N(t,e),set:Y(t,e)});return Array.isArray(e)?e.reduce((t,e)=>(t[e]=r(e,s),t),{}):t(e)?Object.keys(e).reduce((t,o)=>(t[o]=r(e[o],s),t),{}):r(e,s)},B=e=>{if(t(e)){const t="get"in e&&"function"==typeof e.get,s="set"in e&&"function"==typeof e.set;return t||s?c(e):Object.keys(e).reduce((t,s)=>(t[s]=c(e[s]),t),{})}return c(e)};var D=Object.freeze({__proto__:null,MissingStoreError:G,default:E,createState:T,createGetters:W,createActions:I,has:M,get:z,set:J,getter:N,setter:Y,sync:C,computed:B});const{has:H,get:L,set:V,sync:q,computed:F,setter:K,getter:Q,createGetters:R,createState:U,MissingStoreError:X}=D;export default E;export{X as MissingStoreError,b as accessors,F as computed,R as createGetters,U as createState,L as get,Q as getter,H as has,V as set,K as setter,q as sync};
