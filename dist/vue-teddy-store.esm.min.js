/*!
  * vue-teddy-store v0.2.1
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
/*!
  * vue-teddy-store v0.2.1
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
import e,{reactive as t,ref as s,isRef as r,provide as a,inject as o,computed as n,watch as c}from"@vue/composition-api";import{isObject as i,makeSet as u,makeHas as p,makeGet as d,isValidKey as l}from"object-string-path";import y from"vue";const f=(e,t)=>`teddy:${e}:${t}`;var v={store(e,t){const s=ne(e,t);if(s.features.cache)return;const r=window.localStorage||global.localStorage||{};if(r){const a=r.getItem(f(e,t));a&&(s.state={...s.state,...JSON.parse(a)}),M({space:e,name:t},{handler(s,a){s!==a&&r.setItem(f(e,t),JSON.stringify(s))},immediate:!0,deep:!0}),s.features.cache=!0}}},h={store(e,s){const r=ne(e,s);r.features.history||(r.features.history={},r.features.history.stack=t([]),M({space:e,name:s},{handler(e){r.features.history.stack.push({state:e,ts:(new Date).getTime()})},immediate:!0,deep:!0}),r.features.history.installed=!0)}},m={store(e,t){const s=ne(e,t);s.features.sync||(s.features.sync={},window&&window.addEventListener("storage",e=>{e.key===f(t)&&(s.state={...s.state,...JSON.parse(e.newValue)})}),s.features.sync.installed=!0)}},g=Object.freeze({__proto__:null,cache:v,history:h,sync:m});function S(e){if(!i(e)||i(e)&&!("value"in e))return!1;return"function"==typeof Object.getOwnPropertyDescriptor(e,"value").get}function b(e,t,s){return l(t)&&(i(e)||Array.isArray(e))?S(e)&&"value"in e&&t in e.value?(e.value[t]=s,e.value[t]):(e[t]=s,e[t]):e&&null==t?(S(e)&&"value"in e?e.value=s:i(s)?Object.assign(e,s):e=s,e):void console.log("Couldn't not set "+t)}function _(e,t){return l(t)?S(e)?t in e.value?e.value[t]:e.value:i(e)||Array.isArray(e)?e[t]:void 0:e&&void 0===t?S(e)?e.value:e:void 0}function j(e,t){return!(!i(e)&&!Array.isArray(e))&&(!!l(t)&&(!!(S(e)&&e.value&&t in e.value)||(!(!e||!(t in e))||void 0)))}function k(e=[]){return["_state",...e]}const O=u({setProp:b,getProp:_,hasProp:j,afterGetSteps:k}),P=p({getProp:_,hasProp:j,afterGetSteps:k}),w=d({getProp:_,hasProp:j,afterGetSteps:k}),A=u({setProp:b,getProp:_,hasProp:j}),T=p({getProp:_,hasProp:j}),$=d({getProp:_,hasProp:j});var G=Object.freeze({__proto__:null,teddySet:O,teddyHas:P,teddyGet:w,set:A,has:T,get:$});y.use(e);const W=Symbol(),x=Symbol(),z=s({__options:{devtools:!0},spaces:{}}),D=(e="$",t="@")=>{let s=e,r=t;if("string"==typeof e&&e.includes(".")){const t=e.split(".");s=t[0]||s,r=t[1]||r}else e&&i(e)?(s=e.space||s,r=e.name||r):t&&i(t)&&(s=t.space||s,r=t.name||r);return"string"==typeof s&&(s=s.trim()),"string"==typeof r&&(r=r.trim()),{space:s,name:r}},J=(e,t)=>{const s=D(i(e)?e:{name:e});t=t||{};const r=ne(s);return B(s,t.state),E(s,t.getters),H(s,t.actions),M(s,t.watchers),r},N=(e,t)=>r(t)?t:s(t),I=(e,t,s={})=>(s._state=N(0,t),"state"in s||Object.defineProperty(s,"state",{get:()=>s._state.value,set:e=>{s._state.value=e},enumerable:!0}),s),B=(e,t)=>{const s=ne(e);I(0,t,s)},C=(e,t)=>{const s=ne(e);return t=t||{},Object.keys(t).reduce((e,r)=>(S(t[r])?e[r]=t[r]:"function"==typeof t[r]&&(e[r]=le(()=>t[r](s))),e),{})},E=(e,t)=>{const s=ne(e);return s.getters={...s.getters||{},...C(e,t)},s},F=(e,t)=>{const s=ne(e);return t=t||{},Object.keys(t).reduce((e,r)=>("function"==typeof t[r]&&(e[r]=(...e)=>t[r](s,...e)),e),{})},H=(e,t)=>{const s=ne(e);return s.actions={...s.actions||{},...F(e,t)},s},L=(e,t)=>{const{name:s}=D(e),r=ne(e),a=[];return Array.isArray(t)?a.push(...t):t&&a.push(t),0===a.length?[]:a.reduce((e,t)=>{const a=(t,s,r,a)=>{const o=c(s,r,{deep:!0,...a});e.push({path:t,handler:r,options:a,unwatch:o})};if("function"==typeof t)a("state",()=>r.state,t,{deep:!0});else if(t&&"object"==typeof t&&"handler"in t){const{handler:e,path:o,paths:n=[],...c}=t;"string"==typeof o?a(o,()=>w(r,o),e,{deep:!0,...c}):n.length>0?a(n.map(e=>[s,e].filter(Boolean).filter(e=>e.length>0).join(".")),n.map(e=>()=>w(r,e)),e,{deep:!0,...c}):a("state",()=>r.state,e,{deep:!0,...c})}return e},[])},M=(e,t)=>{const s=ne(e);return s.watchers=[...s.watchers||[],...L(e,t)],s},V=e=>{const{space:t,name:s}=D(e);return void 0!==s?t in z.value.spaces&&"stores"in z.value.spaces[t]&&s in z.value.spaces[t].stores:t in z.value.spaces},q=e=>{const{space:t,name:s}=D(e),r=se(t);s in r.stores&&delete r.stores[s]},K=e=>{},Q=(e,t,s)=>{const r=ne(e);return P(r,t,s)},R=(e,t,s)=>{const r=ne(e);return w(r,t,s)},U=(e,t,s)=>function(){return R(e,t,s||this)},X=(e,t,s,r)=>{const a=ne(e);O(a,t,s,r)},Y=(e,t,s)=>function(r){X(e,t,r,s||this)},Z=(e,t,s)=>{const r=(t,s)=>({get:U(e,t,s),set:Y(e,t,s)});return Array.isArray(t)?t.reduce((e,t)=>(e[t]=r(t,s),e),{}):i(t)?Object.keys(t).reduce((e,a)=>(e[a]=r(t[a],s),e),{}):r(t,s)},ee=(e={})=>{"function"==typeof e.teddy&&e.teddy(z.value);for(const t of Object.keys(z.value.spaces||{})){"function"==typeof e.space&&e.space(t);for(const s of Object.keys(z.value.spaces[t].stores||{}))"function"==typeof e.store&&e.store(t,s)}},te=(e=(e=>e))=>({setStore:e(J),makeState:e(N),setState:e(B),applyState:e(I),makeGetters:e(C),setGetters:e(E),makeActions:e(F),setActions:e(H),makeWatchers:e(L),setWatchers:e(M),exists:e(V),remove:e(q),reset:e(K),has:e(Q),get:e(R),getter:e(U),set:e(X),setter:e(Y),sync:e(Z)}),se=(e="$")=>(e in z.value.spaces||(z.value.spaces[e]={}),z.value.spaces[e]),re=(e="$")=>({store:se(e),...te(t=>(...s)=>t({space:e,name:"@"},...s))}),ae=(e="@")=>ne("$",e),oe=(e="@")=>({store:ae(e),...te(t=>(...s)=>t({name:e,space:"$"},...s))}),ne=(e,t)=>{const{space:s,name:r}=D(e,t);return se(s),"stores"in z.value.spaces[s]||(z.value.spaces[s].stores={}),r in z.value.spaces[s].stores||(z.value.spaces[s].stores[r]={getters:{},actions:{},watchers:[],options:{},features:{}},I(0,{},z.value.spaces[s].stores[r])),z.value.spaces[s].stores[r]},ce=(e="$",t="@")=>({store:ne(e,t),...te(s=>(...r)=>s({space:e,name:t},...r))}),ie=(e="$")=>{a(W,re(e))},ue=(...e)=>{a(x,ce(...e))},pe=()=>{o(W)},de=()=>{o(x)},le=e=>{if(i(e)){const t="get"in e&&"function"==typeof e.get,s="set"in e&&"function"==typeof e.set;return t||s?n(e):Object.keys(e).reduce((t,s)=>(t[s]=n(e[s]),t),{})}return n(e)};var ye=Object.freeze({__proto__:null,accessors:G,features:g,Teddy:W,TeddyStore:x,Teddies:z,parseDefinition:D,setStore:J,makeState:N,applyState:I,setState:B,makeGetters:C,setGetters:E,makeActions:F,setActions:H,makeWatchers:L,setWatchers:M,exists:V,remove:q,reset:K,has:Q,get:R,getter:U,set:X,setter:Y,sync:Z,setFeature:ee,mapMethods:te,getTeddy:se,useTeddy:re,getStore:ae,useStore:oe,getTeddyStore:ne,useTeddyStore:ce,provideTeddy:ie,provideTeddyStore:ue,injectTeddy:pe,injectTeddyStore:de,computed:le});const fe=e=>{e.prototype.$teddy=ye};export{z as Teddies,W as Teddy,x as TeddyStore,G as accessors,I as applyState,le as computed,V as exists,g as features,R as get,ae as getStore,se as getTeddy,ne as getTeddyStore,U as getter,Q as has,pe as injectTeddy,de as injectTeddyStore,fe as install,F as makeActions,C as makeGetters,N as makeState,L as makeWatchers,te as mapMethods,D as parseDefinition,ie as provideTeddy,ue as provideTeddyStore,q as remove,K as reset,X as set,H as setActions,ee as setFeature,E as setGetters,B as setState,J as setStore,M as setWatchers,Y as setter,Z as sync,oe as useStore,re as useTeddy,ce as useTeddyStore};
