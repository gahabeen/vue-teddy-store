/*!
  * vue-teddy-store v0.1.29
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
/*!
  * vue-teddy-store v0.1.29
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
import{watch as t,reactive as e,isRef as s,ref as r,computed as n}from"@vue/composition-api";import{isObject as a,makeSet as i,makeHas as o,makeGet as c,isValidKey as l}from"object-string-path";const u=t=>"teddy:store:"+t;var h={handle({name:e,store:s}){const r=window.localStorage||global.localStorage||{};if(r){const n=r.getItem(u(e));n&&(s.state={...s.state,...JSON.parse(n)}),t(s.state,(t,s)=>{t!==s&&r.setItem(u(e),JSON.stringify(t))},{immediate:!0,deep:!0})}}},d={handle({store:s}){s._history=e([]),t(s.state,t=>{s._history.push(t)},{immediate:!0,deep:!0})}},y={handle({name:t,store:s}){window&&window.addEventListener("storage",r=>{r.key===u(t)&&(s.state=e({...s.state,...JSON.parse(r.newValue)}))})}},p=Object.freeze({__proto__:null,cache:h,history:d,sync:y});function f(t){if(!a(t)||a(t)&&!("value"in t))return!1;return"function"==typeof Object.getOwnPropertyDescriptor(t,"value").get}function _(t){return t.filter(Boolean).filter(t=>t.length>0).join(".")}function g(t,e){return l(e)?f(t)?e in t.value?t.value[e]:t.value:a(t)||Array.isArray(t)?t[e]:void 0:t&&void 0===e?f(t)?t.value:t:void 0}function v(t,e){return!(!a(t)&&!Array.isArray(t))&&(!!l(e)&&(!!(f(t)&&t.value&&e in t.value)||(!(!t||!(e in t))||void 0)))}const m=i({setProp:function(t,e,s){return l(e)&&(a(t)||Array.isArray(t))?f(t)&&"value"in t&&e in t.value?(t.value[e]=s,t.value[e]):(t[e]=s,t[e]):t&&null==e?(f(t)&&"value"in t?t.value=s:a(s)?Object.assign(t,s):t=s,t):void console.log("Couldn't not set "+e)},getProp:g,hasProp:v}),w=o({getProp:g,hasProp:v}),b=c({getProp:g,hasProp:v});function A(...t){return t.filter(Boolean).reduce((t,e)=>e instanceof O?e:a(e)&&e.$teddy instanceof O?e.$teddy:t,null)}class O{constructor(){this._vueInstance=null,this._stores={},this._plugins=p}add(e,s){const r=function(t,e=[]){return Object.keys(t).reduce((s,r)=>(e.includes(r)||(s[r]=t[r]),s),{})}(s,["state","getters","actions","watchers"]);this._stores[e]={state:O.createState(s.state),...O.createGetters(s.getters),...s.actions||{},...r},this[e]=this._stores[e];const n=[];Array.isArray(s.watchers)?n.push(...s.watchers):s.watcher&&n.push(s.watcher);for(let s of n)if("function"==typeof s)t(()=>this._stores[e].state.value,s,{deep:!0});else if(s&&"object"==typeof s&&"handler"in s){const{handler:r,path:n,paths:a=[],...i}=s;n?t(()=>b(this._stores[e].state.value,n),r,{deep:!0,...i}):a.length>0?t(a.map(t=>()=>b(this._stores[e].state.value,t)),r,{deep:!0,...i}):t(()=>this._stores[e].state.value,r,{deep:!0,...i})}return this}remove(t){t in this&&delete this[t],t in this._stores&&delete this._stores[t]}use(t={}){return"function"==typeof t.install&&t.install(this),"function"==typeof t.handle&&Object.keys(this._stores).map(e=>t.handle.call(this,{name:e,store:this._stores[e]})),this}activate(t=[]){Array.isArray(t)||(t=[t]);for(let e of t)e in this._plugins&&this.use(this._plugins[e]);return this}attachTo(t){return this._vueInstance=t,this}install(t){const e=this;Object.defineProperty(t.prototype,"$teddy",{get(){return e.attachTo(this)},configurable:!0})}get stores(){return this._stores}static createState(t={}){return s(t)?t:r(t)}static createGetters(t){return t=t||{},Object.keys(t).reduce((e,s)=>(f(t[s])?e[s]=t[s]:"function"==typeof t[s]&&(e[s]=n(t[s])),e),{})}has(t,e,s){return O.has.call(this,t,e,s)}static has(t,e,s){return s=s||this._vueInstance,w(A(this,s),_([`_stores.${t}.state`,e]),s)}get(t,e,s){return O.get.call(this,t,e,s)}static get(t,e,s){return s=s||this._vueInstance,b(A(this,s),_([`_stores.${t}.state`,e]),s)}getter(t,e,s){return O.getter.call(this,t,e,s)}static getter(t,e,s){const r=this;return function(){return O.get.call(A(this,r,s),t,e,s||this)}}set(t,e,s,r){return O.set.call(this,t,e,s,r)}static set(t,e,s,r){r=r||this._vueInstance,m(A(this,r),_([`_stores.${t}.state`,e]),s,r)}setter(t,e,s){return O.setter.call(this,t,e,s)}static setter(t,e,s){const r=this;return function(n){return O.set.call(A(this,r,s),t,e,n,s||this)}}_sync(t,e){return O._sync.call(this,t,e)}static _sync(t,e,s){return{get:O.getter.call(this,t,e,s),set:O.setter.call(this,t,e,s)}}sync(t,e,s){return O.sync.call(this,t,e,s)}static sync(t,e,s){const r=this;return Array.isArray(e)?e.reduce((e,n)=>(e[n]=O._sync.call(r,t,n,s),e),{}):a(e)?Object.keys(e).reduce((n,a)=>(n[a]=O._sync.call(r,t,e[a],s),n),{}):O._sync.call(r,t,e,s)}}export default O;
