/*!
  * vue-teddy-store v0.1.36
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
/*!
  * vue-teddy-store v0.1.36
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
import{isObject as e,makeSet as t,makeHas as s,makeGet as r,isValidKey as a}from"object-string-path";import o from"vue";import n,{ref as c,isRef as u,provide as p,inject as i,computed as d,watch as l}from"@vue/composition-api";function y(t){if(!e(t)||e(t)&&!("value"in t))return!1;return"function"==typeof Object.getOwnPropertyDescriptor(t,"value").get}function v(t,s,r){return a(s)&&(e(t)||Array.isArray(t))?y(t)&&"value"in t&&s in t.value?(t.value[s]=r,t.value[s]):(t[s]=r,t[s]):t&&null==s?(y(t)&&"value"in t?t.value=r:e(r)?Object.assign(t,r):t=r,t):void console.log("Couldn't not set "+s)}function f(t,s){return a(s)?y(t)?s in t.value?t.value[s]:t.value:e(t)||Array.isArray(t)?t[s]:void 0:t&&void 0===s?y(t)?t.value:t:void 0}function h(t,s){return!(!e(t)&&!Array.isArray(t))&&(!!a(s)&&(!!(y(t)&&t.value&&s in t.value)||(!(!t||!(s in t))||void 0)))}function m(e=[]){return["_state",...e]}const g=t({setProp:v,getProp:f,hasProp:h,afterGetSteps:m}),S=s({getProp:f,hasProp:h,afterGetSteps:m}),P=r({getProp:f,hasProp:h,afterGetSteps:m}),b=t({setProp:v,getProp:f,hasProp:h}),j=s({getProp:f,hasProp:h}),A=r({getProp:f,hasProp:h});var _=Object.freeze({__proto__:null,teddySet:g,teddyHas:S,teddyGet:P,set:b,has:j,get:A});o.use(n);const k=Symbol(),T=Symbol(),O=c({__options:{devtools:!0},spaces:{}}),G=(t="$",s="@")=>{let r=t,a=s;return e(t)&&(r=t.space||r,a=t.name||a),{space:r,name:a}},$=(e,t)=>{t=t||{};const s=Z(e);return x(e,t.state),D(e,t.getters),C(e,t.actions),M(e,t.watchers),s},w=(e,t)=>u(t)?t:c(t),W=(e,t,s={})=>(s._state=w(0,t),"state"in s||Object.defineProperty(s,"state",{get:()=>s._state.value,set:e=>{s._state.value=e},enumerable:!0}),s),x=(e,t)=>{const s=Z(e);W(0,t,s)},z=(e,t)=>{const s=Z(e);return t=t||{},Object.keys(t).reduce((e,r)=>(y(t[r])?e[r]=t[r]:"function"==typeof t[r]&&(e[r]=oe(()=>t[r](s))),e),{})},D=(e,t)=>{const s=Z(e);return s.getters={...s.getters||{},...z(e,t)},s},B=(e,t)=>{const s=Z(e);return t=t||{},Object.keys(t).reduce((e,r)=>("function"==typeof t[r]&&(e[r]=(...e)=>t[r](s,...e)),e),{})},C=(e,t)=>{const s=Z(e);return s.actions={...s.actions||{},...B(e,t)},s},H=(e,t)=>{const{name:s}=G(e),r=Z(e),a=[];return Array.isArray(t)?a.push(...t):t&&a.push(t),0===a.length?[]:a.reduce((e,t)=>{const a=(t,s,r,a)=>{const o=l(s,r,{deep:!0,...a});e.push({path:t,handler:r,options:a,unwatch:o})};if("function"==typeof t)a("state",()=>r.state,t,{deep:!0});else if(t&&"object"==typeof t&&"handler"in t){const{handler:e,path:o,paths:n=[],...c}=t;"string"==typeof o?a(o,()=>P(r,o),e,{deep:!0,...c}):n.length>0?a(n.map(e=>[s,e].filter(Boolean).filter(e=>e.length>0).join(".")),n.map(e=>()=>P(r,e)),e,{deep:!0,...c}):a("state",()=>r.state,e,{deep:!0,...c})}return e},[])},M=(e,t)=>{const s=Z(e);return s.watchers=[...s.watchers||[],...H(e,t)],s},q=e=>{const{space:t,name:s}=G(e);return void 0!==s?t in O.value.spaces&&"stores"in O.value.spaces[t]&&s in O.value.spaces[t].stores:t in O.value.spaces},E=e=>{const{space:t,name:s}=G(e),r=U(t);s in r.stores&&delete r.stores[s]},F=e=>{},I=(e,t,s)=>{const r=Z(e);return S(r,t,s)},J=(e,t,s)=>{const r=Z(e);return P(r,t,s)},K=(e,t,s)=>function(){return J(e,t,s||this)},L=(e,t,s,r)=>{const a=Z(e);g(a,t,s,r)},N=(e,t,s)=>function(r){L(e,t,r,s||this)},Q=(t,s,r)=>{const a=(e,s)=>({get:K(t,e,s),set:N(t,e,s)});return Array.isArray(s)?s.reduce((e,t)=>(e[t]=a(t,r),e),{}):e(s)?Object.keys(s).reduce((e,t)=>(e[t]=a(s[t],r),e),{}):a(s,r)},R=(e=(e=>e))=>({setStore:e($),makeState:e(w),setState:e(x),applyState:e(W),makeGetters:e(z),setGetters:e(D),makeActions:e(B),setActions:e(C),makeWatchers:e(H),setWatchers:e(M),exists:e(q),remove:e(E),reset:e(F),has:e(I),get:e(J),getter:e(K),set:e(L),setter:e(N),sync:e(Q)}),U=(e="$")=>(e in O.value.spaces||(O.value.spaces[e]={}),O.value.spaces[e]),V=(e="$")=>({store:U(e),...R(t=>(...s)=>t({space:e,name:"@"},...s))}),X=(e="@")=>Z("$",e),Y=(e="@")=>({store:X(e),...R(t=>(...s)=>t({name:e,space:"$"},...s))}),Z=(e,t)=>{const{space:s,name:r}=G(e,t);return U(s),"stores"in O.value.spaces[s]||(O.value.spaces[s].stores={}),r in O.value.spaces[s].stores||(O.value.spaces[s].stores[r]={getters:{},actions:{},watchers:[],options:{}},W(0,{},O.value.spaces[s].stores[r])),O.value.spaces[s].stores[r]},ee=(e="$",t="@")=>({store:Z(e,t),...R(s=>(...r)=>s({space:e,name:t},...r))}),te=(e="$")=>{p(k,V(e))},se=(...e)=>{p(T,ee(...e))},re=()=>{i(k)},ae=()=>{i(T)},oe=t=>{if(e(t)){const e="get"in t&&"function"==typeof t.get,s="set"in t&&"function"==typeof t.set;return e||s?d(t):Object.keys(t).reduce((e,s)=>(e[s]=d(t[s]),e),{})}return d(t)};var ne=Object.freeze({__proto__:null,accessors:_,Teddy:k,TeddyStore:T,Teddies:O,parseDefinition:G,setStore:$,makeState:w,applyState:W,setState:x,makeGetters:z,setGetters:D,makeActions:B,setActions:C,makeWatchers:H,setWatchers:M,exists:q,remove:E,reset:F,has:I,get:J,getter:K,set:L,setter:N,sync:Q,mapMethods:R,getTeddy:U,useTeddy:V,getStore:X,useStore:Y,getTeddyStore:Z,useTeddyStore:ee,provideTeddy:te,provideTeddyStore:se,injectTeddy:re,injectTeddyStore:ae,computed:oe});const ce=e=>{e.prototype.$teddy=ne};export{O as Teddies,k as Teddy,T as TeddyStore,_ as accessors,W as applyState,oe as computed,q as exists,J as get,X as getStore,U as getTeddy,Z as getTeddyStore,K as getter,I as has,re as injectTeddy,ae as injectTeddyStore,ce as install,B as makeActions,z as makeGetters,w as makeState,H as makeWatchers,R as mapMethods,G as parseDefinition,te as provideTeddy,se as provideTeddyStore,E as remove,F as reset,L as set,C as setActions,D as setGetters,x as setState,$ as setStore,M as setWatchers,N as setter,Q as sync,Y as useStore,V as useTeddy,ee as useTeddyStore};
