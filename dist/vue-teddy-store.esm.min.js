/*!
  * vue-teddy-store v0.1.27
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
/*!
  * vue-teddy-store v0.1.27
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
import{watch as t,reactive as e,isRef as s,ref as r,computed as n}from"@vue/composition-api";import{isObject as i,makeSet as o,makeHas as a,makeGet as c,isValidKey as u}from"object-string-path";const h=t=>"teddy:store:"+t;var l={handle({name:e,store:s}){const r=window.localStorage||global.localStorage||{};if(r){const n=r.getItem(h(e));n&&(s.state={...s.state,...JSON.parse(n)}),t(s.state,(t,s)=>{t!==s&&r.setItem(h(e),JSON.stringify(t))},{immediate:!0,deep:!0})}}},d={handle({store:s}){s._history=e([]),t(s.state,t=>{s._history.push(t)},{immediate:!0,deep:!0})}},p={handle({name:t,store:s}){window&&window.addEventListener("storage",r=>{r.key===h(t)&&(s.state=e({...s.state,...JSON.parse(r.newValue)}))})}},f=Object.freeze({__proto__:null,cache:l,history:d,sync:p});function y(t){if(!i(t)||i(t)&&!("value"in t))return!1;return"function"==typeof Object.getOwnPropertyDescriptor(t,"value").get}function g(t,e){return u(e)?y(t)?e in t.value?t.value[e]:t.value:i(t)||Array.isArray(t)?t[e]:void 0:t&&void 0===e?y(t)?t.value:t:void 0}function _(t,e){return!(!i(t)&&!Array.isArray(t))&&(!!u(e)&&(!(!y(t)||!(e in t.value))||(e in t||void 0)))}const v=o({setProp:function(t,e,s){return u(e)&&(i(t)||Array.isArray(t))?y(t)&&e in t.value?(t.value[e]=s,t.value[e]):(t[e]=s,t[e]):t&&null==e?(y(t)?t.value=s:i(s)?Object.assign(t,s):t=s,t):void console.log("Couldn't not set "+e)},getProp:g,hasProp:_}),m=a({getProp:g,hasProp:_}),w=c({getProp:g,hasProp:_});function O(t){const e=t.filter(t=>t&&i(t)&&t instanceof $),s=t.filter(t=>t&&i(t)&&"$teddy"in t&&t.$teddy instanceof $),r=t.filter(t=>!e.includes(t)&&!s.includes(t));return{instances:e,hosted:s,others:r}}function b(...t){const{instances:e,hosted:s}=O(t),r=[...e,...s.map(t=>t.$teddy)];if(0===!e.length)throw new Error("Couldn't find any proper instance!");return r[0]}function A(...t){const{hosted:e,others:s}=O(t),r=[...e,...s];if(0===!r.length)throw new Error("Couldn't find any proper context!");return r[0]}class ${constructor(){this._stores={},this._plugins=f}add(e,s){const r=function(t,e=[]){return Object.keys(t).reduce((s,r)=>(r.includes(e)||(s[r]=t[r]),s),{})}(s,["state","getters","actions","watchers"]);this._stores[e]={...$.createState(s.state),...$.createGetters(s.getters),...s.actions||{},...r},this[e]=this._stores[e];const n=[];Array.isArray(s.watchers)?n.push(...s.watchers):s.watcher&&n.push(s.watcher);for(let s of n)if("function"==typeof s)t(()=>this._stores[e].state.value,s,{deep:!0});else if(s&&"object"==typeof s&&"handler"in s){const{handler:r,path:n,paths:i=[],...o}=s;n?t(()=>w(this._stores[e].state.value,n),r,{deep:!0,...o}):i.length>0?t(i.map(t=>()=>w(this._stores[e].state.value,t)),r,{deep:!0,...o}):t(()=>this._stores[e].state.value,r,{deep:!0,...o})}return this}remove(t){t in this&&delete this[t],t in this._stores&&delete this._stores[t]}use(t={}){return"function"==typeof t.install&&t.install(this),"function"==typeof t.handle&&Object.keys(this._stores).map(e=>t.handle.call(this,{name:e,store:this._stores[e]})),this}activate(t=[]){Array.isArray(t)||(t=[t]);for(let e of t)e in this._plugins&&this.use(this._plugins[e]);return this}install(t){t.prototype.$teddy=this}get stores(){return this._stores}static createState(t){return s(t=t||{})?t:r(t)}static createGetters(t){return t=t||{},Object.keys(t).reduce((e,s)=>(y(t[s])?e[s]=t[s]:"function"==typeof t[s]&&(e[s]=n(t[s])),e),{})}has(t,e){return $.has(t,e,this)}static has(t,e,s){const r=b(this,s),n=A(this,s);return m(r,`_stores.${t}.state.${e}`,n)}get(t,e){return $.get(t,e,this)}static get(t,e,s){const r=b(this,s),n=A(this,s);return w(r,`_stores.${t}.state.${e}`,n)}getter(t,e){return $.getter(t,e,this)}static getter(t,e,s){return s=s||this,function(){return $.get.call(this,t,e,s)}}set(t,e,s){return $.set(t,e,s,this)}static set(t,e,s,r){const n=b(this,r),i=A(this,r);v(n,`_stores.${t}.state.${e}`,s,i)}setter(t,e){return $.setter(t,e,this)}static setter(t,e,s){return s=s||this,function(r){$.set.call(this,t,e,r,s)}}compute(t,e){return $.compute(t,e,this)}static _compute(t,e,s){s=s||this;return{get:$.getter(t,e,s),set:$.setter(t,e,s)}}static compute(t,e,s){return s=s||this,i(e)?Object.keys(e).reduce((r,n)=>(r[n]=$._compute(t,e[n],s),r),{}):$._compute(t,e,s)}}export default $;
