/*!
  * vue-teddy-store v0.4.1
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
/*!
  * vue-teddy-store v0.4.1
  * (c) 2020 Gabin Desserprit
  * @license MIT
  */
import{reactive as e,isRef as t,unref as s,ref as r,provide as n,inject as o,computed as a,watch as c}from"vue";import{makeSet as i,makeHas as p,makeGet as u,makeRemove as f,makePush as h,makeUnshift as l,makeInsert as d,isValidKey as y,isObject as g}from"object-string-path";import m from"debounce";import P from"fast-deep-equal";import v from"fn-annotate";const S=(e,t)=>`teddy:${e}:${t}`;var _={store(e,t){const s=Ge({space:e,name:t});if(s.features.cache)return;const r=window.localStorage||global.localStorage||{};if(r){const n=r.getItem(S(e,t));n&&(s.state=JSON.parse(n)),pe({space:e,name:t},{handler(s){r.setItem(S(e,t),JSON.stringify(s))},immediate:!0,deep:!0}),s.features.cache=!0}}},w={store(t,s){const r=Ge({space:t,name:s});r.features.history||(r.features.history={},r.features.history.stack=e([]),pe({space:t,name:s},{handler(e){r.features.history.stack.push({state:e,ts:(new Date).getTime()})},immediate:!0,deep:!0}),r.features.history.installed=!0)}},b={store(e,t){const s=Ge({space:e,name:t});s.features.sync||(s.features.sync={},window&&window.addEventListener("storage",r=>{r.key===S(e,t)&&(s.state={...s.state,...JSON.parse(r.newValue)})}),s.features.sync.installed=!0)}},A=Object.freeze({__proto__:null,cache:_,history:w,sync:b});const k=(e={})=>{const t=e.__ob__;return()=>{t&&t.dep.notify()}};function j(e,s,r){const n=t(e);return function(e){const t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}(s)||y(s)?n?(e.value[s]=r,e.value[s]):(e[s]=r,e[s]):n?(e.value=r,e.value):e=r}function O(e,s){if(g(e)||Array.isArray(e))return y(s)?t(e)?e.value[s]:e[s]:t(e)?e.value:e}function G(e,s){return!(!g(e)&&!Array.isArray(e))&&(!!y(s)&&(!(!t(e)||!(s in e.value))||(!(!e||!(s in e))||void 0)))}function $(e,r){const n=s(e),o=t(e),a=k(e);if(Array.isArray(n))return o?(e.value.push(r),a(),e.value.slice(-1)[0]):(e.push(r),a(),e.slice(-1)[0])}function T(e,r){const n=s(e),o=t(e);if(Array.isArray(n))return o?(e.value.unshift(r),e.value):(e.unshift(r),e)}function W(e,r,n){const o=s(e),a=t(e),c=k(e);if(Array.isArray(o))return a?(e.value.splice(r,0,n),c(),e.value):(e.splice(r,0,n),c(),e)}function x(e=[]){return"_state"!==e[0]?["_state",...e]:e}const z=i({setProp:j,getProp:O,hasProp:G,afterGetSteps:x}),F=p({getProp:O,hasProp:G,afterGetSteps:x}),I=u({getProp:O,hasProp:G,afterGetSteps:x}),J=f({getProp:O,hasProp:G,removeProp:function(e,r){const n=s(e),o=t(e),a=k(e);return Array.isArray(n)?(o?e.value.splice(+r,1):e.splice(+r,1),a(),!0):!!g(n)&&(o?delete e.value[r]:delete e[r],a(),!0)},afterGetSteps:x}),N=h({getProp:O,hasProp:G,pushProp:$,afterGetSteps:x}),C=l({getProp:O,hasProp:G,unshiftProp:T,afterGetSteps:x}),M=d({getProp:O,hasProp:G,insertProp:W,afterGetSteps:x}),q=i({setProp:j,getProp:O,hasProp:G}),B=p({getProp:O,hasProp:G}),D=u({getProp:O,hasProp:G}),E=f({getProp:O,hasProp:G}),H=h({getProp:O,hasProp:G,pushProp:$}),L=l({getProp:O,hasProp:G,unshiftProp:T}),R=d({getProp:O,hasProp:G,insertProp:W});var U=Object.freeze({__proto__:null,teddySet:z,teddyHas:F,teddyGet:I,teddyRemove:J,teddyPush:N,teddyUnshift:C,teddyInsert:M,set:q,has:B,get:D,remove:E,push:H,unshift:L,insert:R});const V=Symbol(),K=Symbol(),Q={__options:{devtools:!0},spaces:{}},X="$",Y="@",Z=e=>{let t,s;if(g(e))t="space"in e?e.space:X,s="name"in e?e.name:Y;else if("string"==typeof e)if(e.includes(".")){let[r,n]=e.split(".");t=r,s=n}else if(e.includes("/")){let[r,n]=e.split("/");t=r,s=n}else t=X,s=e;return"string"==typeof t&&(t=t.trim(),0===t.length&&(t=void 0)),"string"==typeof s&&(s=s.trim(),0===s.length&&(s=void 0)),{space:t,name:s}},ee=(e,t)=>{const s=Z(e);t=t||{};const r=Ge(s);return re(s,t.state),oe(s,t.getters),ce(s,t.actions),pe(s,t.watchers),r},te=(e,s)=>t(s)?s:r(s),se=(e,t,s={})=>(s._state=te(0,t),"state"in s||Object.defineProperty(s,"state",{get:()=>s._state.value,set:e=>{s._state.value=e},enumerable:!0}),s),re=(e,t)=>{const s=Ge(e);se(0,t,s)},ne=(e,s)=>{const r=Ge(e);return s=s||{},Object.keys(s).reduce((e,n)=>(t(s[n])?e[n]=s[n]:"function"==typeof s[n]&&(v(s[n]).length>1?e[n]=(...e)=>ze(()=>s[n](r,...e)):e[n]=ze(()=>s[n](r))),e),{})},oe=(e,t)=>{const s=Ge(e);return s.getters={...s.getters||{},...ne(e,t)},s},ae=(e,t)=>{const s=Ge(e);return t=t||{},Object.keys(t).reduce((e,r)=>("function"==typeof t[r]&&(e[r]=(...e)=>t[r](s,...e)),e),{})},ce=(e,t)=>{const s=Ge(e);return s.actions={...s.actions||{},...ae(e,t)},s},ie=(e,t)=>{const{name:s}=Z(e),r=Ge(e),n=[];return Array.isArray(t)?n.push(...t):t&&n.push(t),0===n.length?[]:n.reduce((e,t)=>{const n=(e,t=null)=>{const s=function(t,s){e.call(this,t,s,P(t,s))};return"number"==typeof t?m(s,t,!0):s},o=(e="",t)=>`${e}||${t.toString()}`,a=(t,s,r,a={})=>{e.push({path:t,signature:o(t,r),options:a,start(){return this.unwatch=c(s,n(r,a.debounce),{deep:!0,...a}),this}})};if("function"==typeof t)a("state",()=>r.state,t,{deep:!0});else if(t&&"object"==typeof t&&"handler"in t){const{handler:e,path:n,paths:o=[],...c}=t;"string"==typeof n?a(n,()=>I(r,n),e,{deep:!0,...c}):o.length>0?a(o.map(e=>[s,e].filter(Boolean).filter(e=>e.length>0).join(".")),o.map(e=>()=>I(r,e)),e,{deep:!0,...c}):a("state",()=>r.state,e,{deep:!0,...c})}return e},[])},pe=(e,t)=>{const s=Ge(e);for(const r of ie(e,t)){const e=s.watchers.find(e=>{const t=e.path===r.path,s=e.signature===r.signature;return t&&s});e&&e.unwatch(),s.watchers.push(r.start())}return s},ue=e=>{const{space:t,name:s}=Z(e);return void 0!==s?t in Q.spaces&&"stores"in Q.spaces[t]&&s in Q.spaces[t].stores:t in Q.spaces},fe=e=>{},he=(e,t,...s)=>{const{store:r}=$e(e);if(t in r.actions)try{return r.actions[t](...s)}catch(e){console.error(`Something went wrong with the action '${t}'`),console.error(e)}else console.warn(`Couldn't find the action '${t}' to run.`)},le=(e,t,...s)=>{const{store:r}=$e(e);if(t in r.getters)try{return"function"==typeof r.getters[t]?r.getters[t](...s):r.getters[t]}catch(e){console.error(`Something went wrong with the getter '${t}'`),console.error(e)}else console.warn(`Couldn't find the getter '${t}' to resolve.`)},de=(e,t,s)=>{const{space:r,name:n}=Z(e),o=Ge({space:r,name:n});return J(o,t,s)},ye=(e,t,s)=>{const r=Ge(e);return F(r,t,s)},ge=(e,t,s,r)=>{const{space:n,name:o}=Z(e),a=Ge({space:n,name:o});return I(a,t,s)||r},me=(e,t,s,r)=>function(){return ge(e,t,s||this,r)},Pe=(e,t,s,r)=>{const n=Ge(e);z(n,t,s,r)},ve=(e,t,s)=>function(r){Pe(e,t,r,s||this)},Se=(e,t,s,r)=>{const n=Ge(e);N(n,t,s,r)},_e=(e,t,s,r)=>{const n=Ge(e);M(n,t,s,r)},we=(e,t,s,r)=>{const n=Ge(e);C(n,t,s,r)},be=(e,t,s)=>{const r=(t,s)=>({get:me(e,t,s),set:ve(e,t,s)});return Array.isArray(t)?t.reduce((e,t)=>(e[t]=r(t,s),e),{}):g(t)?Object.keys(t).reduce((e,n)=>(e[n]=r(t[n],s),e),{}):r(t,s)},Ae=(e={})=>{"function"==typeof e.teddy&&e.teddy(Q);for(const t of Object.keys(Q.spaces||{})){"function"==typeof e.space&&e.space(t);for(const s of Object.keys(Q.spaces[t].stores||{}))"function"==typeof e.store&&e.store(t,s)}},ke=(e=(e=>e))=>({setStore:e(ee),makeState:e(te),setState:e(re),applyState:e(se),makeGetters:e(ne),setGetters:e(oe),makeActions:e(ae),setActions:e(ce),makeWatchers:e(ie),setWatchers:e(pe),exists:e(ue),reset:e(fe),run:e(he),resolve:e(le),remove:e(de),has:e(ye),get:e(ge),getter:e(me),set:e(Pe),setter:e(ve),sync:e(be),push:e(Se),unshift:e(we),insert:e(_e)}),je=(e=X)=>(e in Q.spaces||(Q.spaces[e]={}),Q.spaces[e]),Oe=(e=X)=>({store:je(e),...ke(t=>(...s)=>t({space:e,name:Y},...s))}),Ge=e=>{const{space:t=X,name:s=Y}=Z(e);return je(t),"stores"in Q.spaces[t]||(Q.spaces[t].stores={}),s in Q.spaces[t].stores||(Q.spaces[t].stores[s]={getters:{},actions:{},watchers:[],options:{},features:{}},se(0,{},Q.spaces[t].stores[s])),Q.spaces[t].stores[s]},$e=e=>({store:Ge(e),...ke(t=>(...s)=>t(e,...s))}),Te=e=>{n(K,$e(e))},We=()=>{o(V)},xe=()=>{o(K)},ze=e=>{if(g(e)){const t="get"in e&&"function"==typeof e.get,s="set"in e&&"function"==typeof e.set;return t||s?a(e):Object.keys(e).reduce((t,s)=>(t[s]=a(e[s]),t),{})}return a(e)};var Fe=Object.freeze({__proto__:null,accessors:U,features:A,Teddy:V,TeddyStore:K,Teddies:Q,setStore:ee,makeState:te,applyState:se,setState:re,makeGetters:ne,setGetters:oe,makeActions:ae,setActions:ce,makeWatchers:ie,setWatchers:pe,exists:ue,reset:fe,run:he,resolve:le,remove:de,has:ye,get:ge,getter:me,set:Pe,setter:ve,push:Se,insert:_e,unshift:we,sync:be,setFeature:Ae,mapMethods:ke,getTeddy:je,useTeddy:Oe,getStore:Ge,useStore:$e,provideTeddyStore:Te,injectTeddy:We,injectTeddyStore:xe,computed:ze});const Ie=e=>{e.prototype.$teddy=Fe};export{Q as Teddies,V as Teddy,K as TeddyStore,U as accessors,se as applyState,ze as computed,ue as exists,A as features,ge as get,Ge as getStore,je as getTeddy,me as getter,ye as has,We as injectTeddy,xe as injectTeddyStore,_e as insert,Ie as install,ae as makeActions,ne as makeGetters,te as makeState,ie as makeWatchers,ke as mapMethods,Te as provideTeddyStore,Se as push,de as remove,fe as reset,le as resolve,he as run,Pe as set,ce as setActions,Ae as setFeature,oe as setGetters,re as setState,ee as setStore,pe as setWatchers,ve as setter,be as sync,we as unshift,$e as useStore,Oe as useTeddy};
